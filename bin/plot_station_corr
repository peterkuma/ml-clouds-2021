#!/usr/bin/env python3
'''Plot spatial and temporal correlation of stations.

Usage: plot_station_corr TYPE INPUT1 INPUT2 OUTPUT

Arguments:

  TYPE    One of: "time" (time correlation), "space" (space correlation).
  INPUT1  Input file. The output of calc_idd_geo (NetCDF).
  INPUT2  Input file. The output of calc_geo_cto (NetCDF).
  OUTPUT  Output plot (PDF).

Examples:

bin/plot_station_corr space data/idd_geo/2007.nc data/geo_cto/historical/all/CERES.nc plot/station_corr_space.pdf
bin/plot_station_corr time data/idd_geo/2007.nc data/geo_cto/historical/all/CERES.nc plot/station_corr_time.pdf
'''

import sys
import numpy as np
import ds_format as ds
import matplotlib as mpl
from matplotlib import pyplot as plt
from math import radians, degrees, sin, cos, asin, acos, sqrt

mpl.rc('font', family='Open Sans')
mpl.rc('axes', linewidth=0.3)
mpl.rc('axes', grid=True)
mpl.rc('lines', linewidth=1.2)
mpl.rc('xtick.major', width=0.3)
mpl.rc('ytick.major', width=0.3)
mpl.rc('legend', framealpha=1)
mpl.rc('legend', facecolor='#eeeeee')
mpl.rc('legend', edgecolor='none')
mpl.rc('legend', fancybox=False)
mpl.rc('legend', fontsize=8)
mpl.rc('grid', color='k')
mpl.rc('grid', alpha=0.2)
mpl.rc('grid', lw=0.1)

N = 100000 # Number of point combinations to evaluate.
COLORS = ['#0084C8', '#DC0000', '#009100', '#FFC022']
CLOUD_TYPES = ['High', 'Middle', 'Cumuliform', 'Stratiform']

def calc_dist(lon1, lat1, lon2, lat2):
	lon1, lat1, lon2, lat2 = map(radians, [lon1, lat1, lon2, lat2])
	dlon = lon2 - lon1
	dlat = lat2 - lat1
	a = sin(dlat/2)**2 + cos(lat1)*cos(lat2)*sin(dlon/2)**2
	return 2*6371*asin(sqrt(a))

if __name__ == '__main__':
	if len(sys.argv) != 5:
		sys.stderr.write(sys.modules[__name__].__doc__)
		sys.exit(1)
	type_ = sys.argv[1]
	input1 = sys.argv[2]
	input2 = sys.argv[3]
	output = sys.argv[4]

	print('<- %s' % input1)
	d1 = ds.read(input1, ['time'])
	print('<- %s' % input2)
	d2 = ds.read(input2, ['time'])

	time = sorted(list(set(d1['time']) & set(d2['time'])))

	ii1 = np.searchsorted(d1['time'], time)
	ii2 = np.searchsorted(d2['time'], time)

	print('<- %s' % input1)
	d1 = ds.read(input1, sel={'time': ii1})
	print('<- %s' % input2)
	d2 = ds.read(input2, sel={'time': ii2})

	x1 = d1['cloud_occurrence_daily']
	x2 = d2['cloud_occurrence_daily']

	err = x2 - x1
	for i in range(err.shape[1]):
		err[:,i,::] -= np.nanmean(err, axis=1)
	stats = d1['stats_daily']
	stats_n = d1['stats_n_daily']
	nclasses, n, m, l = x1.shape

	xmax = 5000
	xstep = 200
	xbins = np.arange(0, xmax + xstep, xstep)
	x = 0.5*(xbins[1:] + xbins[:-1])

	tmax = 180
	tstep = 1
	tbins = np.arange(0, tmax + tstep, tstep)
	t = 0.5*(tbins[1:] + tbins[:-1])

	if type_ == 'space':
		plt.title('Spatial correlation of CERES/ANN error relative to IDD at stations')
		plt.xlabel('Distance (km)')
		for i in range(nclasses):
			ax = [[] for i in range(len(xbins))]
			bx = [[] for i in range(len(xbins))]
			j = 0
			while j < N:
				itime = np.random.randint(0, n)
				ilat1 = np.random.randint(0, m)
				ilat2 = np.random.randint(0, m)
				ilon1 = np.random.randint(0, l)
				ilon2 = np.random.randint(0, l)
				if stats_n[i,itime,ilat1,ilon1] < 10 or \
				   stats_n[i,itime,ilat2,ilon2] < 10:
					continue
				if np.isnan(err[i,itime,ilat1,ilon1]) or \
				   np.isnan(err[i,itime,ilat2,ilon2]):
					continue
				dx = calc_dist(
					d1['lon'][ilon1], d1['lat'][ilat1],
					d1['lon'][ilon2], d1['lat'][ilat2]
				)
				j += 1
				k = int(dx/xstep)
				if k >= len(xbins) - 1:
					continue
				ax[k] += [err[i,itime,ilat1,ilon1]]
				bx[k] += [err[i,itime,ilat2,ilon2]]
			plt.plot(
				x,
				[np.corrcoef(ax[k], bx[k])[0,1] for k in range(len(xbins) - 1)],
				color=COLORS[i],
				label=CLOUD_TYPES[i]
			)

	if type_ == 'time':
		plt.title('Temporal correlation of CERES/ANN error relative to IDD at stations')
		plt.xlabel('Time difference (days)')
		for i in range(nclasses):
			at = [[] for i in range(len(tbins))]
			bt = [[] for i in range(len(tbins))]
			j = 0
			while j < N:
				itime1 = np.random.randint(0, n)
				itime2 = itime1 + np.random.randint(
					max(-itime1, -tmax),
					min(n - itime1, tmax)
				)
				ilat = np.random.randint(0, m)
				ilon = np.random.randint(0, l)
				if stats_n[i,itime1,ilat,ilon] < 10 or \
				   stats_n[i,itime2,ilat,ilon] < 10:
					continue
				if np.isnan(err[i,itime1,ilat,ilon]) or \
				   np.isnan(err[i,itime2,ilat,ilon]):
					continue
				dt = np.abs(d1['time'][itime2] - d1['time'][itime1])
				j += 1
				k = int(dt/tstep)
				if k >= len(tbins) - 1:
					continue

				at[k] += [err[i,itime1,ilat,ilon]]
				bt[k] += [err[i,itime2,ilat,ilon]]
			plt.plot(
				t,
				[np.corrcoef(at[k], bt[k])[0,1] for k in range(len(tbins) - 1)],
				color=COLORS[i],
				label=CLOUD_TYPES[i]
			)

	plt.legend()
	plt.ylabel('Correlation coefficient')
	print('-> %s' % output)
	plt.savefig(output, bbox_inches='tight')
