#!/usr/bin/env python3
'''
Plot spatial and temporal correlation of stations.

Usage: bin/plot_station_corr <type> <input1> <input2> <output>

Arguments:

- type: One of: "time" (time correlation), "space" (space correlation).
- input1: Input file - the output of calc_idd_geo (NetCDF).
- input2: Input file - the output of calc_geo_cto (NetCDF).
- output: Output plot (PDF).
'''

import sys
import numpy as np
import ds_format as ds
import matplotlib as mpl
from matplotlib import pyplot as plt
from math import radians, degrees, sin, cos, asin, acos, sqrt

mpl.rc('font', family='Open Sans')
mpl.rc('axes', linewidth=0.3)
mpl.rc('axes', grid=True)
mpl.rc('lines', linewidth=1.2)
mpl.rc('xtick.major', width=0.3)
mpl.rc('ytick.major', width=0.3)
mpl.rc('legend', framealpha=1)
mpl.rc('legend', facecolor='#eeeeee')
mpl.rc('legend', edgecolor='none')
mpl.rc('legend', fancybox=False)
mpl.rc('legend', fontsize=8)
mpl.rc('grid', color='k')
mpl.rc('grid', alpha=0.2)
mpl.rc('grid', lw=0.1)

COLORS = ['#0084C8', '#DC0000', '#009100', '#FFC022']
CLOUD_TYPES = ['High', 'Middle', 'Cumuliform', 'Stratiform']

def calc_dist(lon1, lat1, lon2, lat2):
	lon1, lat1, lon2, lat2 = map(radians, [lon1, lat1, lon2, lat2])
	dlon = lon2 - lon1
	dlat = lat2 - lat1
	a = sin(dlat/2)**2 + cos(lat1)*cos(lat2)*sin(dlon/2)**2
	return 2*6371*asin(sqrt(a))

if __name__ == '__main__':
	if len(sys.argv) != 5:
		sys.stderr.write(sys.modules[__name__].__doc__)
		sys.exit(1)
	type_ = sys.argv[1]
	input1 = sys.argv[2]
	input2 = sys.argv[3]
	output = sys.argv[4]

	d1 = ds.read(input1)
	d2 = ds.read(input2)

	x1 = d1['cloud_occurrence_daily']
	x2 = d2['cloud_occurrence_daily']
	err = x2 - x1
	print(np.nanmean(err, axis=(1,2,3)))
	for i in range(err.shape[1]):
		err[:,i,::] -= np.nanmean(err, axis=1)
	stats = d1['stats_daily']
	stats_n = d1['stats_n_daily']
	nclasses, n, m, l = x1.shape

	N = 100000

	#dt = np.zeros(N)
	#dx = np.zeros(N)

	xmax = 5000
	xstep = 200
	xbins = np.arange(0, xmax + xstep, xstep)
	x = 0.5*(xbins[1:] + xbins[:-1])
	#ax = np.zeros(len(xbins) - 1)
	#bx = np.zeros(len(xbins) - 1)

	tmax = 180
	tstep = 1
	tbins = np.arange(0, tmax + tstep, tstep)
	t = 0.5*(tbins[1:] + tbins[:-1])
	#at = np.zeros(len(tbins) - 1)
	#bt = np.zeros(len(tbins) - 1)

	if type_ == 'space':
		plt.title('Spatial correlation of CERES/ANN error relative to IDD at stations')
		plt.xlabel('Distance (km)')
		for i in range(nclasses):
			ax = [[] for i in range(len(xbins))]
			bx = [[] for i in range(len(xbins))]
			j = 0
			while j < N:
				itime = np.random.randint(0, n)
				ilat1 = np.random.randint(0, m)
				ilat2 = np.random.randint(0, m)
				ilon1 = np.random.randint(0, l)
				ilon2 = np.random.randint(0, l)
				if stats_n[i,itime,ilat1,ilon1] < 10 or \
				   stats_n[i,itime,ilat2,ilon2] < 10:
					continue
				if np.isnan(err[i,itime,ilat1,ilon1]) or \
				   np.isnan(err[i,itime,ilat2,ilon2]):
					continue
				dx = calc_dist(
					d1['lon'][ilon1], d1['lat'][ilat1],
					d1['lon'][ilon2], d1['lat'][ilat2]
				)
				j += 1
				k = int(dx/xstep)
				if k >= len(xbins) - 1:
					continue
				ax[k] += [err[i,itime,ilat1,ilon1]]
				bx[k] += [err[i,itime,ilat2,ilon2]]
			plt.plot(
				x,
				[np.corrcoef(ax[k], bx[k])[0,1] for k in range(len(xbins) - 1)],
				color=COLORS[i],
				label=CLOUD_TYPES[i]
			)

	#if type_ == 'space':
	#	for i in range(nclasses):
	#		ax = [[] for i in range(len(xbins))]
	#		bx = [[] for i in range(len(xbins))]
	#		j = 0
	#		while j < N:
	#			#itime1 = np.random.randint(0, n)
	#			#itime2 = itime1 + np.random.randint(max(-itime1, -10), min(n - itime1, 10))
	#			ilat1 = np.random.randint(0, m)
	#			ilat2 = np.random.randint(0, m)
	#			ilon1 = np.random.randint(0, l)
	#			ilon2 = np.random.randint(0, l)
	#			itime1 = 0
	#			itime2 = 0
	#			if stats_n[i,itime1,ilat1,ilon1] < 10 or \
	#			   stats_n[i,itime2,ilat2,ilon2] < 10:
	#				continue
	#			#dt[j] = np.abs(d['time'][itime2] - d['time'][itime1])
	#			dx = calc_dist(
	#				d1['lon'][ilon1], d1['lat'][ilat1],
	#				d1['lon'][ilon2], d1['lat'][ilat2]
	#			)
	#			j += 1
	#			k = int(dx/xstep)
	#			if k >= len(xbins) - 1:
	#				continue
	#			#ax[k] += x[i,itime1,ilat1,ilon1]*x[i,itime2,ilat2,ilon2] + \
	#			#	(1 - x[i,itime1,ilat1,ilon1])*(1 - x[i,itime2,ilat2,ilon2])
	#			#bx[k] += 1
	#	plt.plot(
	#		x,
	#		ax/bx,
	#		color=COLORS[i],
	#		label=CLOUD_TYPES[i]
	#	)

	if type_ == 'time':
		plt.title('Temporal correlation of CERES/ANN error relative to IDD at stations')
		plt.xlabel('Time difference (days)')
		for i in range(nclasses):
			at = [[] for i in range(len(tbins))]
			bt = [[] for i in range(len(tbins))]
			j = 0
			while j < N:
				itime1 = np.random.randint(0, n)
				itime2 = itime1 + np.random.randint(
					max(-itime1, -tmax),
					min(n - itime1, tmax)
				)
				ilat = np.random.randint(0, m)
				ilon = np.random.randint(0, l)
				if stats_n[i,itime1,ilat,ilon] < 10 or \
				   stats_n[i,itime2,ilat,ilon] < 10:
					continue
				if np.isnan(err[i,itime1,ilat,ilon]) or \
				   np.isnan(err[i,itime2,ilat,ilon]):
					continue
				dt = np.abs(d1['time'][itime2] - d1['time'][itime1])
				j += 1
				k = int(dt/tstep)
				if k >= len(tbins) - 1:
					continue

				at[k] += [err[i,itime1,ilat,ilon]]
				bt[k] += [err[i,itime2,ilat,ilon]]

				#at[k] += x[i,itime1,ilat,ilon]*x[i,itime2,ilat,ilon] + \
				#	(1 - x[i,itime1,ilat,ilon])*(1 - x[i,itime2,ilat,ilon])
				#bt[k] += 1
			plt.plot(
				t,
				[np.corrcoef(at[k], bt[k])[0,1] for k in range(len(tbins) - 1)],
				color=COLORS[i],
				label=CLOUD_TYPES[i]
			)

	plt.legend()
	plt.ylabel('Correlation coefficient')

	#print(at[1], bt[1])
	#plt.plot(t, at/bt)
	#print([np.corrcoef(at[k], bt[k])[0,1] for k in range(len(tbins) - 1)])
	#plt.plot(t, [len(at[k]) for k in range(len(tbins) - 1)])

	plt.savefig(output, bbox_inches='tight')
