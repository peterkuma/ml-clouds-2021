#!/usr/bin/env python3
'''Plot geographical distribution of cloud type occurrence.

Usage: plot_geo_cto <deg> <relative> <input> <ecs> <output>

Depends on: calc_geo_cto

Arguments:

- deg: Degree. One of: 0 (absolute value) or 1 (trend).
- relative: Plot relative to CERES. One of: true or false.
- input: Input directory - the output of calc_geo_cto (NetCDF).
- ecs: ECS file (CSV).
- output: Output plot (PDF).

Examples:

bin/plot_geo_cto 0 true data/geo_cto/historical/part_1 data/ecs/ecs.csv plot/geo_cto_historical_1.pdf
bin/plot_geo_cto 0 true data/geo_cto/historical/part_2 data/ecs/ecs.csv plot/geo_cto_historical_2.pdf
'''

import sys
import os
import string
import numpy as np
import ds_format as ds
import matplotlib.pyplot as plt
import matplotlib as mpl
import cartopy.crs as ccrs
import pst
import pandas as pd

mpl.rc('font', family='Open Sans')
mpl.rc('axes', linewidth=0.3)
mpl.rc('axes', grid=True)
mpl.rc('lines', linewidth=1.2)
mpl.rc('xtick.major', width=0.3)
mpl.rc('ytick.major', width=0.3)
mpl.rc('legend', framealpha=1)
mpl.rc('legend', facecolor='#eeeeee')
mpl.rc('legend', edgecolor='none')
mpl.rc('legend', fancybox=False)
mpl.rc('legend', fontsize=8)
mpl.rc('grid', color='k')
mpl.rc('grid', alpha=0.2)
mpl.rc('grid', lw=0.1)

CLOUD_TYPES = ['High', 'Middle', 'Cumuliform', 'Strafiform']

def read_ecs(filename):
	d = pd.read_csv(filename)
	return {
		'model': np.array(d['Model']),
		'ecs': np.array(d['ECS']),
		'tcr': np.array(d['TCR']),
		'cld': np.array(d['CLD']),
		'ext_ecs': np.array(d['Extended_ECS']),
		'ext_tcr': np.array(d['Extended_TCR']),
		'ext_cld': np.array(d['Extended_CLD']),
		'.': {
			'model': {'.dims': ['model']},
			'ecs': {'.dims': ['model']},
			'tcr': {'.dims': ['model']},
			'cld': {'.dims': ['model']},
			'ext_scs': {'.dims': ['model']},
			'ext_tcr': {'.dims': ['model']},
			'ext_cld': {'.dims': ['model']},
		}
	}

def get_ecs(d_ecs, var, model):
	try:
		i = np.where(d_ecs['model'] == model)[0][0]
		return d_ecs[var][i], (d_ecs['ext_'+var][i] == 'Y')
	except IndexError:
		return np.nan, False

if __name__ == '__main__':
	args, opts = pst.decode_argv(sys.argv, as_unicode=True)
	if len(args) != 6:
		sys.stderr.write(sys.modules[__name__].__doc__)
		sys.exit(1)
	deg = args[1]
	relative = args[2]
	input_ = args[3]
	ecs = args[4]
	output = args[5]

	var = {
		0: 'stats_geo',
		1: 'stats_geo1',
	}[deg]

	var_alt = {
		0: 'cloud_occurrence',
		1: 'cloud_occurrence_1',
	}[deg]

	abs_levels = {
		0: 100.*np.arange(0.15, 0.875, 0.025),
		1: 100.*np.arange(-0.05, 0.055, 0.005),
	}[deg]

	rel_levels = {
		0: 100.*np.arange(-0.4, 0.402, 0.02),
		1: 100.*np.arange(-0.025, 0.026, 0.001),
	}[deg]

	label = {
		0: 'Cloud type occurrence error (%)',
		1: 'Cloud type occurrence trend (% K$^{-1}$)',
	}[deg]

	units = {
		0: '%',
		1: '%K$^{-1}$',
	}[deg]

	cmap = mpl.colors.LinearSegmentedColormap.from_list('cmap', list(reversed(['#D72322', '#EF3B24', '#F04D23', '#F16C23', '#F59434', '#FDC24D', '#FFF582', '#FFFFFF', '#AFDEE1', '#62CAE9', '#2AAFE4', '#198DCD', '#3A5DA9', '#403092', '#343091'])), 512)

	print('<- %s' % input_)
	dd = ds.readdir(input_)

	print('<- %s' % ecs)
	d_ecs = read_ecs(ecs)

	nrows = len(dd)
	ncols = len(CLOUD_TYPES)

	figsize = (8, 12.4*nrows/11)
#		7: (8, 6),
#		8: (8, 7.85),
#		9: (8, 8.84),
#		10: (8, 9.8),
#		11: (8, 12.4),
#		12: (8, 12),
#	}[nrows]

	fig = plt.figure(figsize=figsize)

	d_ceres = None
	for i, d in enumerate(dd):
		name = os.path.basename(d['filename'])[:-3]
		d['name'] = name
		if name == 'CERES':
			d_ceres = d

	dd_wo_ceres = [d for d in dd if d is not d_ceres]

	for d in dd_wo_ceres:
		d['ecs'], d['ext'] = get_ecs(d_ecs, 'ecs', d['name'])
	order = np.argsort([d['ecs'] for d in dd_wo_ceres])
	dd_wo_ceres = [dd_wo_ceres[i] for i in order]

	dd_all = [d_ceres] + dd_wo_ceres if d_ceres is not None else dd_wo_ceres

	if d_ceres is None:
		relative = False

	cf = None
	cf_ref = None

	for i, d in enumerate(dd_all):
		name = os.path.basename(d['filename'])[:-3]
		total_mse = 0.
		for j, cloud_type in enumerate(CLOUD_TYPES):
			ax = fig.add_subplot(nrows, ncols, i*ncols + j + 1,
				projection=ccrs.PlateCarree())
			plt.text(0.01, 0.98, '%s%d)' % (string.ascii_lowercase[i], j+1),
				transform=ax.transAxes,
				va='top',
				ha='left',
				fontsize=7,
				weight='bold',
			)
			if name != 'CERES':
				varx = var if var in d else var_alt
				varx_ceres = var if var in d_ceres else var_alt
				if varx not in d:
					print('Skipping %s because it does not define required variables' % name)
					continue
				if d[varx].ndim == 4:
					z = d[varx][0,j,:,:]
				else:
					z = d[varx][j,:,:]
				if relative:
					if d_ceres[varx_ceres].ndim == 4:
						z -= d_ceres[varx_ceres][0,j,:,:]
					else:
						z -= d_ceres[varx_ceres][j,:,:]
				cf = ax.contourf(d['lon'], d['lat'], z*100.,
					levels=(rel_levels if relative else abs_levels),
					cmap='bwr',
				)
				latg, long_ = np.meshgrid(d['lat'], d['lon'])
				weights = np.cos(latg.T/180.*np.pi)
				e_mean = np.average(z*100., weights=weights)
				if relative:
					mse = np.average((z*100.)**2, weights=weights)
					ax.text(0.5, -0.02, 'ME %.0f%% | RMSE %.0f%%' % (
							e_mean, np.sqrt(mse),
						),
						transform=ax.transAxes,
						fontsize=7,
						ha='center',
						va='top',
					)
					total_mse += mse
					if j == len(CLOUD_TYPES) - 1:
						ax.text(1.02, 0.5,
							'Tot. RMSE %.0f%%' % np.sqrt(total_mse/len(CLOUD_TYPES)),
							transform=ax.transAxes,
							fontsize=7,
							ha='left',
							va='center',
							rotation=90.,
						)
				else:
					fmt = 'mean %d%s' if deg == 0 else 'mean %.2f%s'
					ax.text(0.5, -0.02, fmt % (e_mean, units),
						transform=ax.transAxes,
						fontsize=7,
						ha='center',
						va='top',
					)
			else:
				varx = var if var in d else var_alt
				varx_ceres = var if var in d_ceres else var_alt
				if d[varx].ndim == 4:
					z = d[varx][0,j,:,:]
				else:
					z = d[varx][j,:,:]
				cf_ref = ax.contourf(d['lon'], d['lat'], z*100.,
					levels=abs_levels,
					cmap=('viridis' if deg == 0 else 'bwr'),
				)
				latg, long_ = np.meshgrid(d['lat'], d['lon'])
				weights = np.cos(latg.T/180.*np.pi)
				e_mean = np.average(z*100., weights=weights)
				ax.text(0.5, -0.02, 'mean %d%s' % (e_mean, units),
					transform=ax.transAxes,
					fontsize=7,
					ha='center',
					va='top',
				)

			ax.coastlines(lw=0.4)
			ax.outline_patch.set_linewidth(0.2)
			if i == 0:
				ax.text(0.5, 1.1, cloud_type,
					transform=ax.transAxes,
					va='center',
					ha='center',
					fontsize=7,
				)
			if j == 0:
				if 'ecs' in d and np.isfinite(d['ecs']):
					star = '$^*$' if d['ext'] else ''
					ax.text(-0.07, 0.5,
						name + ('\nECS %.1f K%s' % (d['ecs'], star)),
						transform=ax.transAxes, va='center', ha='center',
						rotation=90, fontsize=(6.5 if len(name) > 12 else 7))
				else:
					ax.text(-0.03, 0.5, name, transform=ax.transAxes, \
						va='center', ha='center', rotation=90, fontsize=7)

	plt.subplots_adjust(hspace=0.06, wspace=0, right=0.89)

	if relative:
		# Horizontal:
		# cax = fig.add_axes([0.125, 0.092, 0.35, 0.007])
		# Vertical:
		cax = fig.add_axes([0.915, 0.525, 0.01, 0.2])
		cb = fig.colorbar(cf_ref, cax=cax, ticks=np.arange(0, 110, 10),
			orientation='vertical')
		cb.set_label(label='Cloud type occurrence (%)', fontsize=7)
		cb.ax.tick_params(labelsize=6)

	# Horizontal:
	#cax = fig.add_axes([0.54, 0.092, 0.35, 0.007] if relative else \
	#	[0.33, 0.092, 0.35, 0.007])
	# Vertical:
	cax = fig.add_axes([0.915, 0.275, 0.01, 0.2] if relative else \
		[0.33, 0.092, 0.35, 0.007])
	cb = fig.colorbar(cf, cax=cax, orientation='vertical')
	cb.set_label(label=label, fontsize=7)
	cb.ax.tick_params(labelsize=6)

	print('-> %s' % output)
	plt.savefig(output, bbox_inches='tight')
